@using LionFire.Trading.Automation.Blazor.Optimization
@using Plotly.Blazor
@using Plotly.Blazor.LayoutLib
@using Plotly.Blazor.Traces
@using Plotly.Blazor.Traces.ScatterLib
@using Plotly.Blazor.LayoutLib.XAxisLib
@using Plotly.Blazor.LayoutLib.AnnotationLib
@using System.Reactive.Linq
@inject IJSRuntime JS
@implements IDisposable

<style>
    .equity-chart-container .rangeslider-rangeplot {
        opacity: 0;
        transition: opacity 0.2s;
    }
    .equity-chart-container .rangeslider-container:hover .rangeslider-rangeplot {
        opacity: 1;
    }
</style>

<div style="display: flex; flex-direction: column; height: 100%;">
    <div class="d-flex flex-row align-center gap-2 mb-2">
        <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="@Refresh" Size="Size.Small" />
        <MudText Typo="Typo.body2" Class="mud-text-secondary">
            @VisibleCount visible of @FilteredCount filtered (@TotalCount total)
        </MudText>
    </div>

    <div id="@_containerId" class="equity-chart-container" style="flex: 1; min-height: 150px;">
        <PlotlyChart @bind-Config="config" @bind-Layout="layout" @bind-Data="data" @ref="chart" Style="height: 100%; width: 100%;" />
    </div>
</div>

@code {
    [Parameter] public IOptimizationResultsVM? ViewModel { get; set; }

    private PlotlyChart? chart;
    private Config? config;
    private Layout? layout;
    private IList<ITrace>? data;
    private IDisposable? _subscription;
    private readonly string _containerId = $"equity-{Guid.NewGuid():N}";
    private bool _resizeObserverInitialized;

    private int VisibleCount => ViewModel?.GetChartVisibleBacktests().Count() ?? 0;
    private int FilteredCount => ViewModel?.FilteredCount ?? 0;
    private int TotalCount => ViewModel?.TotalCount ?? 0;

    public void Refresh()
    {
        data = GenerateChartData();
        chart?.React();
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        config = new Config { Responsive = true };

        layout = new Layout
        {
            XAxis = new List<XAxis>
            {
                new XAxis
                {
                    AutoRange = AutoRangeEnum.True,
                    RangeSlider = new Plotly.Blazor.LayoutLib.XAxisLib.RangeSlider { AutoRange = true },
                    Type = Plotly.Blazor.LayoutLib.XAxisLib.TypeEnum.Date
                }
            },
            YAxis = new List<YAxis>
            {
                new YAxis
                {
                    Title = null
                }
            },
            Title = null,
            PaperBgColor = "#1A1A27",
            PlotBgColor = "#1A1A27",
            Font = new Plotly.Blazor.LayoutLib.Font { Color = "#FFFFFF" },
            ShowLegend = false,
            Margin = new Plotly.Blazor.LayoutLib.Margin
            {
                L = 40,  // Left - minimal space for y-axis labels
                R = 5,   // Right - minimal
                T = 5,   // Top - minimal
                B = 5    // Bottom - minimal below range slider
            },
            Annotations = new List<Annotation>
            {
                new Annotation
                {
                    Text = "Balance",
                    XRef = "paper",
                    YRef = "paper",
                    X = (object)0.01,
                    Y = (object)0.99,
                    XAnchor = XAnchorEnum.Left,
                    YAnchor = YAnchorEnum.Top,
                    ShowArrow = false,
                    Font = new Plotly.Blazor.LayoutLib.AnnotationLib.Font
                    {
                        Color = "#888888",
                        Size = 11
                    }
                }
            }
        };

        data = GenerateChartData();

        // Subscribe to visibility and data changes
        if (ViewModel != null)
        {
            _subscription = ViewModel.ChartVisibilityChanged
                .Merge(ViewModel.Changes)
                .Merge(ViewModel.DebouncedChanges)
                .Throttle(TimeSpan.FromMilliseconds(250))
                .Subscribe(_ => InvokeAsync(Refresh));
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_resizeObserverInitialized)
        {
            _resizeObserverInitialized = true;
            try
            {
                await JS.InvokeVoidAsync("chartResizeObserver.observe", _containerId, null);
            }
            catch
            {
                // JS interop may fail during prerender
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    public void Dispose()
    {
        _subscription?.Dispose();
        if (_resizeObserverInitialized)
        {
            try
            {
                _ = JS.InvokeVoidAsync("chartResizeObserver.unobserve", _containerId);
            }
            catch
            {
                // Ignore disposal errors
            }
        }
    }

    private IList<ITrace> GenerateChartData()
    {
        var traces = new List<ITrace>();
        if (ViewModel?.Backtests == null) return traces;

        var selected = ViewModel.SelectedBacktest;

        foreach (var result in ViewModel.GetChartVisibleBacktests())
        {
            var isSelected = result == selected;
            var trace = CreateTrace(result, isSelected);
            if (trace != null)
            {
                traces.Add(trace);
            }
        }

        // Add selected trace last so it renders on top
        if (selected != null && ViewModel.IsVisibleInChart(selected))
        {
            // Remove the selected trace from its current position and add it at the end
            var selectedTrace = traces.FirstOrDefault(t => t is Scatter s && s.Name == selected.StringId);
            if (selectedTrace != null)
            {
                traces.Remove(selectedTrace);
                traces.Add(selectedTrace);
            }
        }

        return traces;
    }

    private Scatter? CreateTrace(BacktestBatchJournalEntry result, bool isSelected)
    {
        if (result.JournalEntries == null) return null;

        var x = new List<object>();
        var y = new List<object>();
        float balance = 0f;

        foreach (var j in result.JournalEntries.Cast<JournalEntry>())
        {
            if (!j.RealizedGrossProfitDeltaFloat.HasValue || j.RealizedGrossProfitDeltaFloat.Value == 0f) continue;
            x.Add(j.Time.DateTime.ToString("o")); // ISO 8601 format for Plotly date axis
            balance += j.RealizedGrossProfitDeltaFloat.Value;
            y.Add(balance);
        }

        if (x.Count == 0) return null;

        return new Scatter
        {
            Name = result.StringId,
            Mode = ModeFlag.Lines,
            X = x,
            Y = y,
            Line = new Line
            {
                Width = isSelected ? 3.0m : 1.0m,
                Color = GetLineColor(result, isSelected)
            }
        };
    }

    private string GetLineColor(BacktestBatchJournalEntry result, bool isSelected)
    {
        if (result.IsAborted)
        {
            return isSelected ? "#808080" : "#404040"; // Gray for aborted, brighter if selected
        }

        // Get base color from AD value
        string baseColor;
        if (result.AD > 3.0) baseColor = "#4040FF";
        else if (result.AD > 2.0) baseColor = "#10F010";
        else if (result.AD > 0.5) baseColor = "#30b030";
        else if (result.AD > 0.0) baseColor = "#004000";
        else if (result.AD > -0.5) baseColor = "#400000";
        else if (result.AD > -1.5) baseColor = "#800000";
        else baseColor = "#a00000";

        if (isSelected)
        {
            return BrightenColor(baseColor);
        }

        return baseColor;
    }

    private static string BrightenColor(string hexColor)
    {
        // Parse hex color
        var r = Convert.ToInt32(hexColor.Substring(1, 2), 16);
        var g = Convert.ToInt32(hexColor.Substring(3, 2), 16);
        var b = Convert.ToInt32(hexColor.Substring(5, 2), 16);

        // Brighten by blending toward white (increase values, with min floor for visibility)
        const int minBrightness = 80;
        const double blendFactor = 0.35;

        r = Math.Max(minBrightness, (int)(r + (255 - r) * blendFactor));
        g = Math.Max(minBrightness, (int)(g + (255 - g) * blendFactor));
        b = Math.Max(minBrightness, (int)(b + (255 - b) * blendFactor));

        return $"#{r:X2}{g:X2}{b:X2}";
    }
}
