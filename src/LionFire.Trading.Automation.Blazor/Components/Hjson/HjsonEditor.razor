@namespace LionFire.Trading.Automation.Blazor.Components.Hjson
@using Hjson
@using Microsoft.Extensions.Logging
@inject ILogger<HjsonEditor> Logger

<div class="hjson-editor" style="height: @Options.Height">
    <div class="editor-toolbar">
        <MudButtonGroup Variant="Variant.Outlined" Size="Size.Small">
            <MudButton OnClick="FormatAsync" StartIcon="@Icons.Material.Filled.FormatAlignLeft"
                       Disabled="@Options.ReadOnly">
                Format
            </MudButton>
            <MudButton OnClick="ValidateSyntax" StartIcon="@Icons.Material.Filled.Check">
                Validate
            </MudButton>
        </MudButtonGroup>

        @if (_syntaxValid.HasValue)
        {
            <MudChip T="string"
                     Color="@(_syntaxValid.Value ? Color.Success : Color.Error)"
                     Size="Size.Small"
                     Class="ml-2">
                @(_syntaxValid.Value ? "Valid HJSON" : "Invalid")
            </MudChip>
        }
    </div>

    <MudTextField @bind-Value="_internalValue"
                  @bind-Value:after="OnInternalValueChanged"
                  Variant="Variant.Outlined"
                  Lines="@Options.Rows"
                  FullWidth="true"
                  Immediate="true"
                  ReadOnly="@Options.ReadOnly"
                  Placeholder="@Options.Placeholder"
                  Class="hjson-textarea"
                  Style="font-family: 'Consolas', 'Monaco', monospace; font-size: 13px;" />

    @if (!string.IsNullOrEmpty(_syntaxError))
    {
        <MudAlert Severity="Severity.Error" Class="mt-2" Dense="true">
            @_syntaxError
        </MudAlert>
    }
</div>

<style>
    .hjson-editor {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .editor-toolbar {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .hjson-textarea .mud-input-slot {
        font-family: 'Consolas', 'Monaco', monospace !important;
    }
</style>

@code {
    private bool? _syntaxValid;
    private string? _syntaxError;
    private string? _lastValidatedValue;
    private string _internalValue = "";
    private string? _lastExternalValue;

    [Parameter] public string Value { get; set; } = "";
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public HjsonEditorOptions Options { get; set; } = new();
    [Parameter] public EventCallback<bool> OnValidationChanged { get; set; }

    protected override void OnParametersSet()
    {
        // Only sync from parent when Value actually changed externally
        if (Value != _lastExternalValue)
        {
            Logger.LogInformation("HjsonEditor.OnParametersSet: External value changed from parent, syncing (length {OldLen} -> {NewLen})",
                _lastExternalValue?.Length ?? 0, Value?.Length ?? 0);
            _internalValue = Value;
            _lastExternalValue = Value;

            // Clear validation when external value changes
            if (Value != _lastValidatedValue)
            {
                _syntaxValid = null;
                _syntaxError = null;
            }
        }
    }

    private async Task OnInternalValueChanged()
    {
        // Propagate internal changes back to parent
        if (_internalValue != Value)
        {
            Value = _internalValue;
            _lastExternalValue = _internalValue;
            await ValueChanged.InvokeAsync(_internalValue);
        }
    }

    private async Task FormatAsync()
    {
        if (string.IsNullOrWhiteSpace(_internalValue)) return;

        try
        {
            // Parse HJSON and re-serialize with formatting
            var parsed = global::Hjson.HjsonValue.Parse(_internalValue);
            var formatted = parsed.ToString(global::Hjson.Stringify.Hjson);
            _internalValue = formatted;
            Value = formatted;
            _lastExternalValue = formatted;
            await ValueChanged.InvokeAsync(formatted);
            _syntaxValid = true;
            _syntaxError = null;
        }
        catch (Exception ex)
        {
            _syntaxValid = false;
            _syntaxError = $"Format failed: {ex.Message}";
        }

        await OnValidationChanged.InvokeAsync(_syntaxValid ?? false);
    }

    private async Task ValidateSyntax()
    {
        await ValidateSyntaxAsync();
    }

    /// <summary>
    /// Validates the HJSON syntax programmatically.
    /// </summary>
    public async Task ValidateSyntaxAsync()
    {
        Logger.LogInformation("HjsonEditor.ValidateSyntaxAsync: Starting, _internalValue length={Length}", _internalValue?.Length ?? 0);
        if (string.IsNullOrWhiteSpace(_internalValue))
        {
            Logger.LogInformation("HjsonEditor.ValidateSyntaxAsync: Value is empty");
            _syntaxValid = null;
            _syntaxError = null;
            return;
        }

        try
        {
            global::Hjson.HjsonValue.Parse(_internalValue);
            _syntaxValid = true;
            _syntaxError = null;
            _lastValidatedValue = _internalValue;
            Logger.LogInformation("HjsonEditor.ValidateSyntaxAsync: Parse succeeded, _syntaxValid={Valid}", _syntaxValid);
        }
        catch (Exception ex)
        {
            _syntaxValid = false;
            _syntaxError = ex.Message;
            _lastValidatedValue = _internalValue;
            Logger.LogWarning("HjsonEditor.ValidateSyntaxAsync: Parse failed: {Error}", ex.Message);
        }

        await OnValidationChanged.InvokeAsync(_syntaxValid ?? false);
        Logger.LogInformation("HjsonEditor.ValidateSyntaxAsync: Done, IsValid={IsValid}", IsValid);
    }

    /// <summary>
    /// Gets whether the current content is valid HJSON.
    /// </summary>
    public bool IsValid => _syntaxValid ?? false;

    /// <summary>
    /// Gets the current syntax error message, if any.
    /// </summary>
    public string? SyntaxError => _syntaxError;
}
