@namespace LionFire.Trading.Automation.Blazor.Components.Optimization
@using LionFire.Trading.Optimization.Execution

<div class="plan-results-tab">
    @if (ExecutionState == null || ExecutionState.CompletedJobs == 0)
    {
        <MudText Typo="Typo.body1" Class="mud-text-secondary text-center pa-8">
            No results yet. Complete some jobs to see results.
        </MudText>
    }
    else
    {
        @* Summary Statistics *@
        <MudCard Class="mb-4" Elevation="0" Outlined="true">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">Results Summary</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <MudGrid>
                    <MudItem xs="6" sm="3">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Avg Score</MudText>
                        <MudText Typo="Typo.h5" Color="@GetScoreColor(GetAverageScore())">
                            @GetAverageScore().ToString("F1")
                        </MudText>
                    </MudItem>
                    <MudItem xs="6" sm="3">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Best Score</MudText>
                        <MudText Typo="Typo.h5" Color="Color.Success">
                            @GetBestScore().ToString("F1")
                        </MudText>
                    </MudItem>
                    <MudItem xs="6" sm="3">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Total Backtests</MudText>
                        <MudText Typo="Typo.h5">
                            @GetTotalBacktests().ToString("N0")
                        </MudText>
                    </MudItem>
                    <MudItem xs="6" sm="3">
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">Scoring Rate</MudText>
                        <MudText Typo="Typo.h5">
                            @GetScoringRate().ToString("P0")
                        </MudText>
                    </MudItem>
                </MudGrid>
            </MudCardContent>
        </MudCard>

        @* Results Matrix Heatmap *@
        <MudCard Class="mb-4" Elevation="0" Outlined="true">
            <MudCardHeader>
                <CardHeaderContent>
                    <div class="d-flex align-center justify-space-between flex-grow-1">
                        <MudText Typo="Typo.h6">Results Matrix</MudText>
                        <div class="d-flex align-center gap-2">
                            <MudSelect T="string" Value="@_selectedDateRange" ValueChanged="OnDateRangeChanged"
                                       Label="Date Range" Dense="true" Margin="Margin.Dense" Variant="Variant.Outlined"
                                       Style="min-width: 150px;">
                                <MudSelectItem T="string" Value="@("")">All Ranges</MudSelectItem>
                                @foreach (var range in GetAvailableDateRanges())
                                {
                                    <MudSelectItem T="string" Value="@range">@range</MudSelectItem>
                                }
                            </MudSelect>
                            <MudMenu Icon="@Icons.Material.Filled.Download" Size="Size.Small" Dense="true"
                                     Title="Export" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight">
                                <MudMenuItem OnClick="ExportCsv" Icon="@Icons.Material.Filled.TableChart">Export CSV</MudMenuItem>
                                <MudMenuItem OnClick="ExportJson" Icon="@Icons.Material.Filled.Code">Export JSON</MudMenuItem>
                            </MudMenu>
                        </div>
                    </div>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent>
                <ResultsMatrixHeatmap
                    Jobs="@ExecutionState?.Jobs"
                    Loading="false"
                    SelectedDateRange="@_selectedDateRange"
                    OnCellClick="OnHeatmapCellClick" />
            </MudCardContent>
        </MudCard>

        @* Top Results Table *@
        <MudCard Class="mb-4" Elevation="0" Outlined="true">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">Top Results by Score</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="pa-0">
                <MudSimpleTable Dense="true" Hover="true">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Symbol</th>
                            <th>Timeframe</th>
                            <th>Date Range</th>
                            <th style="text-align: right;">Score</th>
                            <th style="text-align: right;">Best AD</th>
                        </tr>
                    </thead>
                    <tbody>
                        @{ var rank = 1; }
                        @foreach (var job in GetTopResults(20))
                        {
                            <tr>
                                <td>@rank</td>
                                <td>@job.Symbol</td>
                                <td>@job.Timeframe</td>
                                <td>@job.StartDate.ToString("yyyy-MM-dd") - @job.EndDate.ToString("yyyy-MM-dd")</td>
                                <td style="text-align: right;">
                                    <MudText Color="@GetScoreColor(job.Score!.Value)">@job.Score.Value.ToString("F2")</MudText>
                                </td>
                                <td style="text-align: right;">@(job.BestAD?.ToString("F2") ?? "-")</td>
                            </tr>
                            rank++;
                        }
                    </tbody>
                </MudSimpleTable>
            </MudCardContent>
        </MudCard>

        @* Results by Symbol *@
        <MudCard Elevation="0" Outlined="true">
            <MudCardHeader>
                <CardHeaderContent>
                    <MudText Typo="Typo.h6">Results by Symbol</MudText>
                </CardHeaderContent>
            </MudCardHeader>
            <MudCardContent Class="pa-0">
                <MudSimpleTable Dense="true" Hover="true">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th style="text-align: right;">Jobs</th>
                            <th style="text-align: right;">Avg Score</th>
                            <th style="text-align: right;">Best Score</th>
                            <th style="text-align: right;">Total Backtests</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var group in GetResultsBySymbol())
                        {
                            <tr>
                                <td>@group.Symbol</td>
                                <td style="text-align: right;">@group.Count</td>
                                <td style="text-align: right;">
                                    <MudText Color="@GetScoreColor(group.AvgScore)">@group.AvgScore.ToString("F1")</MudText>
                                </td>
                                <td style="text-align: right;">
                                    <MudText Color="Color.Success">@group.BestScore.ToString("F1")</MudText>
                                </td>
                                <td style="text-align: right;">@group.TotalBacktests.ToString("N0")</td>
                            </tr>
                        }
                    </tbody>
                </MudSimpleTable>
            </MudCardContent>
        </MudCard>
    }
</div>

@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation

@code {
    [Parameter] public PlanExecutionState? ExecutionState { get; set; }
    [Parameter] public EventCallback<OptimizationJob> OnJobSelected { get; set; }

    private string _selectedDateRange = "";

    private IEnumerable<string> GetAvailableDateRanges()
    {
        if (ExecutionState?.Jobs == null) return Enumerable.Empty<string>();

        return ExecutionState.Jobs
            .Where(j => j.Status == JobStatus.Completed)
            .Select(j => j.DateRange.Name)
            .Where(n => !string.IsNullOrEmpty(n))
            .Distinct()
            .OrderBy(n => n);
    }

    private void OnDateRangeChanged(string value)
    {
        _selectedDateRange = value;
        StateHasChanged();
    }

    private async Task OnHeatmapCellClick(OptimizationJob job)
    {
        if (OnJobSelected.HasDelegate)
        {
            await OnJobSelected.InvokeAsync(job);
        }
    }

    private async Task ExportCsv()
    {
        var jobs = GetCompletedWithScore()
            .Where(j => string.IsNullOrEmpty(_selectedDateRange) || j.DateRange.Name == _selectedDateRange);

        var csv = new System.Text.StringBuilder();
        csv.AppendLine("Symbol,Timeframe,DateRange,StartDate,EndDate,Score,BestAD,TotalBacktests,GoodBacktestCount");

        foreach (var job in jobs.OrderBy(j => j.Symbol).ThenBy(j => j.Timeframe))
        {
            csv.AppendLine($"{job.Symbol},{job.Timeframe},{job.DateRange.Name},{job.StartDate:yyyy-MM-dd},{job.EndDate:yyyy-MM-dd},{job.Score?.ToString("F2") ?? ""},{job.BestAD?.ToString("F2") ?? ""},{job.TotalBacktests ?? 0},{job.GoodBacktestCount ?? 0}");
        }

        await DownloadFile("results-matrix.csv", csv.ToString(), "text/csv");
    }

    private async Task ExportJson()
    {
        var jobs = GetCompletedWithScore()
            .Where(j => string.IsNullOrEmpty(_selectedDateRange) || j.DateRange.Name == _selectedDateRange)
            .Select(j => new
            {
                j.Symbol,
                j.Timeframe,
                DateRange = j.DateRange.Name,
                StartDate = j.StartDate.ToString("yyyy-MM-dd"),
                EndDate = j.EndDate.ToString("yyyy-MM-dd"),
                j.Score,
                j.BestAD,
                j.TotalBacktests,
                j.GoodBacktestCount
            });

        var json = System.Text.Json.JsonSerializer.Serialize(jobs, new System.Text.Json.JsonSerializerOptions { WriteIndented = true });
        await DownloadFile("results-matrix.json", json, "application/json");
    }

    private async Task DownloadFile(string filename, string content, string mimeType)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);
        await JSRuntime.InvokeVoidAsync("eval", $@"
            (function() {{
                var link = document.createElement('a');
                link.href = 'data:{mimeType};base64,{base64}';
                link.download = '{filename}';
                link.click();
            }})();
        ");
    }

    private IEnumerable<OptimizationJob> GetCompletedWithScore() =>
        ExecutionState?.Jobs.Where(j => j.Status == JobStatus.Completed && j.Score.HasValue)
            ?? Enumerable.Empty<OptimizationJob>();

    private double GetAverageScore()
    {
        var jobs = GetCompletedWithScore().ToList();
        return jobs.Count > 0 ? jobs.Average(j => j.Score!.Value) : 0;
    }

    private double GetBestScore()
    {
        var jobs = GetCompletedWithScore().ToList();
        return jobs.Count > 0 ? jobs.Max(j => j.Score!.Value) : 0;
    }

    private long GetTotalBacktests() =>
        ExecutionState?.Jobs.Where(j => j.TotalBacktests.HasValue).Sum(j => (long)j.TotalBacktests!.Value) ?? 0;

    private double GetScoringRate()
    {
        if (ExecutionState?.CompletedJobs == 0) return 0;
        return (double)GetCompletedWithScore().Count() / ExecutionState!.CompletedJobs;
    }

    private IEnumerable<OptimizationJob> GetTopResults(int count) =>
        GetCompletedWithScore().OrderByDescending(j => j.Score).Take(count);

    private IEnumerable<SymbolGroup> GetResultsBySymbol() =>
        GetCompletedWithScore()
            .GroupBy(j => j.Symbol)
            .Select(g => new SymbolGroup
            {
                Symbol = g.Key,
                Count = g.Count(),
                AvgScore = g.Average(j => j.Score!.Value),
                BestScore = g.Max(j => j.Score!.Value),
                TotalBacktests = g.Sum(j => j.TotalBacktests ?? 0)
            })
            .OrderByDescending(g => g.BestScore);

    private Color GetScoreColor(double score)
    {
        if (score >= 80) return Color.Success;
        if (score >= 60) return Color.Warning;
        return Color.Error;
    }

    private record SymbolGroup
    {
        public string Symbol { get; init; } = "";
        public int Count { get; init; }
        public double AvgScore { get; init; }
        public double BestScore { get; init; }
        public long TotalBacktests { get; init; }
    }
}
